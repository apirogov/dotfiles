" useful blocks for latex
Plug 'rbonvall/vim-textobj-latex'
" Latex -> :Latexmk/:LatexView
Plug 'LaTeX-Box-Team/LaTeX-Box', { 'for': ['latex','tex'] }
au BufRead,BufNewFile *.tex let g:neomake_tex_enabled_makers = []
let g:LatexBox_viewer='zathura'
" let g:LatexBox_latexmk_options='-latexoption="-synctex=1 \%O \%S" -latexoption=--shell-escape'
let g:LatexBox_custom_indent=0 " conflicts with neocomplete
let g:LatexBox_quickfix=2 " don't steal focus
let g:LatexBox_latexmk_async=0 " auto rebuild on changes
let g:LatexBox_latexmk_preview_continuously=1 " auto rebuild on changes

" let g:syntastic_tex_checkers = ['chktex']
let g:syntastic_tex_checkers = []
au BufRead,BufNewFile *.tex     nnoremap <F9> :!zathura --synctex-forward <C-R>=line('.')<CR>:<C-R>=col('.')<CR>:<C-R>=expand("%:p%:t")<CR> <C-R>=LatexBox_GetOutputFile()<CR> > /dev/null<CR><CR>
au BufRead,BufNewFile *.tex     map <F8>  :w<cr>:Latexmk<cr>
au BufRead,BufNewFile *.tex     map <F7>  :w<cr>:silent !zathura -x "vim --servername <C-R>=v:servername<CR> --remote +\%{line} \%{input}" <C-R>=LatexBox_GetOutputFile()<CR> & > /dev/null<cr>
au BufRead,BufNewFile *.tex     map <F6>  :w<cr>:LatexErrors<cr>

" C/C++
inoremap <leader><Tab> <C-x><C-o>
Plug 'vim-scripts/a.vim', { 'for': ['c','cpp'] }
" Plug 'justmao945/vim-clang', { 'for': ['c','cpp'] }
let g:clang_c_options = '-std=gnu11 -Wall -Wextra'
Plug 'brookhong/cscope.vim', { 'for': ['c','cpp'] }
let g:cscope_silent=1
au FileType c,cpp call s:cscopeMappings()
function s:cscopeMappings()
nnoremap <buffer> <silent> <leader>fa :call CscopeFindInteractive(expand('<cword>'))<CR>
nnoremap <buffer> <silent> <leader>l :call ToggleLocationList()<CR>
" s: Find this C symbol
nnoremap <buffer> <silent> <leader>fs :call CscopeFind('s', expand('<cword>'))<CR>
" g: Find this definition
nnoremap <buffer> <silent> <leader>fg :call CscopeFind('g', expand('<cword>'))<CR>
" d: Find functions called by this function
nnoremap <buffer> <silent> <leader>fd :call CscopeFind('d', expand('<cword>'))<CR>
" c: Find functions calling this function
nnoremap <buffer> <silent> <leader>fc :call CscopeFind('c', expand('<cword>'))<CR>
" t: Find this text string
nnoremap <buffer> <silent> <leader>ft :call CscopeFind('t', expand('<cword>'))<CR>
" e: Find this egrep pattern
nnoremap <buffer> <silent> <leader>fe :call CscopeFind('e', expand('<cword>'))<CR>
" f: Find this file
nnoremap <buffer> <silent> <leader>ff :call CscopeFind('f', expand('<cword>'))<CR>
" i: Find files #including this file
nnoremap <buffer> <silent> <leader>fi :call CscopeFind('i', expand('<cword>'))<CR>
endfunction

" Haskell plugins and config
" --------------------------
" Better install all necessary stuff globally with stack:
" ghc-mod, hasktags, hlint, hoogle

" Hoogle interface from vim (see :help hoogle)
Plug 'Twinside/vim-hoogle', { 'for': 'haskell' }
" Haskell tab completion with ghc-mod
Plug 'Shougo/vimproc.vim', {'do': 'make'}
Plug 'eagletmt/ghcmod-vim', { 'for': 'haskell' }
let g:ghcmod_ghc_options = ['-fno-warn-unused-do-bind','-fno-warn-unused-binds']
" Plug 'eagletmt/neco-ghc'

" type checking and lint
au FileType haskell nnoremap <buffer> <silent> <F1> :GhcModType<CR>
au FileType haskell nnoremap <buffer> <silent> <F3> :GhcModInfo<CR>
au FileType haskell nnoremap <buffer> <silent> <F3> :GhcModTypeClear<CR>
au BufRead,BufNewFile *.hs let g:neomake_haskell_enabled_makers = []
au BufWritePost *.hs silent! GhcModCheck

" for hacking on xmonad
autocmd BufRead,BufNewFile ~/.xmonad/* call s:add_xmonad_path()
function! s:add_xmonad_path()
  call add(g:ghcmod_ghc_options, '-i' . expand('~/.xmonad/lib'))
endfunction

" for making ghc-mod work with stack outside of projects
autocmd BufRead,BufNewFile *.hs call s:add_stack_db()
function! s:add_stack_db()
  if !exists('g:ghcmod_ghc_options')
    let g:ghcmod_ghc_options = []
  endif
  let pkgdbs = system("stack exec env 2>/dev/null | grep PACKAGE_SANDBOXES | sed 's/^.*=//' | sed 's/:/\\n/g' | head -n-1")
  for pkgdb in split(pkgdbs)
    call add(g:ghcmod_ghc_options, '-package-db ' . pkgdb)
  endfor
endfunction

" lushtags is not maintained.. hasktags works better
if executable('hasktags')
let g:tagbar_type_haskell = {
    \ 'ctagsbin'  : 'hasktags',
    \ 'ctagsargs' : '-x -c -o-',
    \ 'kinds'     : [
        \  'm:modules:0:1',
        \  'd:data: 0:1',
        \  'd_gadt: data gadt:0:1',
        \  't:type names:0:1',
        \  'nt:new types:0:1',
        \  'c:classes:0:1',
        \  'cons:constructors:1:1',
        \  'c_gadt:constructor gadt:1:1',
        \  'c_a:constructor accessors:1:1',
        \  'ft:function types:1:1',
        \  'fi:function implementations:0:1',
        \  'o:others:0:1'
    \ ],
    \ 'sro'        : '.',
    \ 'kind2scope' : {
        \ 'm' : 'module',
        \ 'c' : 'class',
        \ 'd' : 'data',
        \ 't' : 'type'
    \ },
    \ 'scope2kind' : {
        \ 'module' : 'm',
        \ 'class'  : 'c',
        \ 'data'   : 'd',
        \ 'type'   : 't'
    \ }
\ }
endif
